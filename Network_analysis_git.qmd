---
title: "Network analysis"
format:
  html:
    embed-resources: true
editor: visual
---

```{r}
#| label = "setup",
#| include = FALSE
knitr::opts_chunk$set(echo = TRUE)
```

### Community level reproductive success

escalamos variables con rescale. Eliminamos filas de sitios donde no hay informacion de mean reproductive success para analisis de exito reproductivo.

```{r loading}
#| warning: false
#| message: false
rm(list = ls(all.names = TRUE)) 
pacman::p_unload(pacman::p_loaded(), character.only = TRUE) 
pacman::p_load(tidyverse,here, patchwork, purrr, dplyr, lme4, carData,effects, easystats, lmertTest, performance,see,gridExtra,car, AICcmodavg, lattice,ggplot2,bipartite, glmmTMB, nlme, performance)


sitems<-read.csv(here("data","useful", "sitems_meanrepro.csv"))
#villa.s <- sitems %>%
 # subset(Site_id == "Doñana" & Bosque == "Villamanrique Chaparral" & Year == "2021" & Periodo=="2")
  
sitems$Year<-as.factor(sitems$Year)
sitems$Bosque<-as.character(sitems$Bosque)
sitems$Periodo<-as.factor(sitems$Periodo)

glimpse(sitems)
sitems_rescaled <- sitems %>%
  mutate(Anidamiento = scale(Anidamiento),
         comp.fun.pol = scale(comp.fun.pol),
         comp.fun.pl = scale(comp.fun.pl), 
         robustness.pol = scale(robustness.pol), 
         robustness.pl = scale(robustness.pl), 
         total.visits = scale(total.visits),
         poll.sp = scale(poll.sp),
         plant.sp = scale(plant.sp),
         asymmetry = scale(asymmetry),
         connectance = scale(connectance))

sitems.fs <- sitems_rescaled %>%
  filter(!is.na(mean.fs)& !is.nan(mean.fs))
sitems.fs <- sitems.fs %>%
  mutate(mean.fs = if_else(mean.fs == 1, 0.9999, mean.fs))

```

```{r repro}
#| warning: false
#| message: false

library(dplyr)
sitems.fs.d<-sitems.fs%>%
  filter(sitems.fs$Site_id=="Doñana")

sitems.fs.g<-sitems.fs%>%
  filter(sitems.fs$Site_id=="Gorbea")


sitems.fs.g$Periodo <- as.factor(sitems.fs.g$Periodo)
sitems.fs.d$Periodo <- as.factor(sitems.fs.d$Periodo)
sitems.fs.g$Bosque <- as.factor(sitems.fs.g$Bosque)
sitems.fs.d$Bosque <- as.factor(sitems.fs.d$Bosque)

library(nlme)
library(glmmTMB)

library(performance)
library(nlme)
m5_lme <- lme(
  mean.fs ~ poll.sp + plant.sp + Anidamiento + comp.fun.pol + total.visits,  # Sin Periodo
  random = list( ~ 1 | Bosque, ~ 1 | Year),
  correlation = corAR1(form = ~ Periodo | Bosque),  # Correlación AR(1) por Bosque
  method = "ML",
  data = sitems.fs.g
)
check_collinearity(m5_lme)


model_glmmTMB.g <- glmmTMB(
  mean.fs ~ poll.sp + plant.sp + Anidamiento + comp.fun.pol +  Periodo + (1 | Bosque) + (1 | Year),
  family = "beta_family",
  data = sitems.fs.g
)

model_glmmTMB.d <- glmmTMB(
  mean.fs ~ poll.sp + plant.sp + Anidamiento + comp.fun.pol +  Periodo + (1 | Bosque) + (1 | Year),
  family = "beta_family",
  data = sitems.fs.d
)


model_glmmTMB.int <- glmmTMB(
  mean.fs ~ (poll.sp + plant.sp + Anidamiento + comp.fun.pol) *  Periodo * Year + (1 | Bosque),
  family = "beta_family",
  data = sitems.fs.g
)

summary(model_glmmTMB.int)


model_glmmTMB.gint1 <- glmmTMB(
  mean.fs ~ poll.sp + plant.sp + (Anidamiento + total.visits) * Periodo + (1 | Bosque) ,
  family = beta_family(),
  data = sitems.fs.g
)


model_glmmTMB.dint <- glmmTMB(
  mean.fs ~ (poll.sp + plant.sp + Anidamiento + comp.fun.pol) *       Periodo + (1 | Bosque) ,
  family = beta_family(),
  data = sitems.fs.d
)

model_glmmTMB.dint1 <- glmmTMB(
  mean.fs ~ poll.sp + plant.sp + (Anidamiento + comp.fun.pol) *       Periodo + (1 | Bosque) ,
  family = beta_family(),
  data = sitems.fs.d
)





```

```{r fomulak}
#| warning: false
#| message: false


model_comparison <- data.frame(
 Model = c("glmmTMB.g", "glmmTMB.d","glmmTMB.int", "glmmTMB.gint1", "glmmTMB.dint", "glmmTMB.dint1"),
  AIC = c(AIC(model_glmmTMB.g), AIC(model_glmmTMB.d), AIC(model_glmmTMB.int), AIC(model_glmmTMB.gint1),  AIC(model_glmmTMB.dint),AIC(model_glmmTMB.dint1)),
  BIC = c(BIC(model_glmmTMB.g),BIC(model_glmmTMB.d), BIC(model_glmmTMB.int), BIC(model_glmmTMB.gint1), BIC(model_glmmTMB.dint), BIC(model_glmmTMB.dint1)))

# Mostrar comparación de AIC y BIC
print(model_comparison)
par(mfrow = c(2, 2))
plot(resid(model_glmmTMB.gint1) ~ fitted(model_glmmTMB.gint1),
     main = "Residuos glmmTMB",
     xlab = "Valores ajustados",
     ylab = "Residuos")
qqnorm(resid(model_glmmTMB.gint1))

# Histograma de residuos
hist(resid(model_glmmTMB.g), main = "Histograma de residuos glmmTMB", xlab = "Residuos")

par(mfrow = c(2, 2))
plot(resid(model_glmmTMB.int) ~ fitted(model_glmmTMB.int),
     main = "Residuos glmmTMB",
     xlab = "Valores ajustados",
     ylab = "Residuos")
qqnorm(resid(model_glmmTMB.int))
# Histograma de residuos
hist(resid(model_glmmTMB.int), main = "Histograma de residuos glmmTMB", xlab = "Residuos")






###GLMMTMB MODELOA ASKOZE HOBEA CON BETA FAMILY

# List of model formulas for fruit set
formulas <- list(
  m6 = mean.fs ~ poll.sp + plant.sp + (Anidamiento + comp.fun.pol) *  Periodo * Year + (1 | Bosque),
  m7 = mean.fs ~ poll.sp + plant.sp + (Anidamiento + total.visits) *  Periodo * Year + (1 | Bosque)
)

models.g <- map(formulas, ~ glmmTMB(.x, family = "beta_family", data = sitems.fs.g))

formulas.d <- list(
  m6 = mean.fs ~ poll.sp + plant.sp + (Anidamiento + comp.fun.pol) *  Periodo + (1 | Bosque),
  m7 = mean.fs ~ poll.sp + plant.sp + (Anidamiento + total.visits) * Periodo  + (1 | Bosque)
)

models.d <- map(formulas.d, ~ glmmTMB(.x, family = "beta_family", data = sitems.fs.d))

sitems.fs.d.sub<-subset(sitems.fs.d, sitems.fs.d$comp.fun.pol<2)
str(sitems.fs.d.sub)

models.d.sub <- map(formulas.d, ~ glmmTMB(.x, family = "beta_family", data = sitems.fs.d.sub))

aic_results <- map(models.g, AIC)
print(aic_results)
aic_results <- map(models.d, AIC)
print(aic_results)
aic_results <- map(models.d.sub, AIC)
print(aic_results)
```

gorbea aprox deltaAIC\<2 para los dos modelos. doñana mejor el de compl funcional

con map todos los plots de los modelos anteriores.

**Tabla modelos estructura funcion**

```{r tables}
#| warning: false
#| message: false
library(gridExtra)
library(grid)
install.packages("kableExtra")
library(kableExtra)


resultados_d <- map_dfr(models.d, ~ {
  coef_summary <- summary(.x)$coefficients$cond
  tibble::as_tibble(coef_summary, rownames = "term") %>%
    mutate(modelo = deparse(substitute(.x)), Region = "Doñana")
}, .id = "modelo_d")

resultados_d.sub <- map_dfr(models.d.sub, ~ {
  coef_summary <- summary(.x)$coefficients$cond
  tibble::as_tibble(coef_summary, rownames = "term") %>%
    mutate(modelo = deparse(substitute(.x)), Region = "Doñana")
}, .id = "modelo.d.sub")

# Extraer estimates, std.error y z value para modelos de Gorbea (modelos 2 y 3)
resultados_g <- map_dfr(models.g, ~ {
  coef_summary <- summary(.x)$coefficients$cond
  tibble::as_tibble(coef_summary, rownames = "term") %>%
    mutate(modelo = deparse(substitute(.x)), Region = "Gorbea")
}, .id = "modelo_g")

resultados_d <- resultados_d %>%
  select( Region,model= modelo_d, term, Estimate = Estimate, `Std. Error` = `Std. Error`, `Z value` = `z value`, `p value`= `Pr(>|z|)`)

resultados_d.sub<- resultados_d.sub %>%
  select( Region,model= modelo.d.sub, term, Estimate = Estimate, `Std. Error` = `Std. Error`, `Z value` = `z value`, `p value`= `Pr(>|z|)`)

resultados_g <- resultados_g %>%
  select(Region, model= modelo_g, term, Estimate = Estimate, `Std. Error` = `Std. Error`, `Z value` = `z value`,  `p value`= `Pr(>|z|)`)


library(kableExtra)
# Combinar los resultados en una sola tabla
tabla_final <- bind_rows(resultados_d.sub, resultados_g)

tabla_final_df <- as.data.frame(tabla_final)
tabla_final_df <- tabla_final_df %>%
  mutate(negrita =`p value` < 0.05) 
# Crear una tabla con desplazamiento horizontal
tabla_kable <- tabla_final_df %>%
  select(-negrita) %>% 
  kable("html") %>%
  kable_styling("striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#0073e6") %>% # Estilo del encabezado
  column_spec(1:5, border_left = TRUE) # Estilo de columnas

# Aplicar estilo de negrita para las filas con p < 0.05
for (i in which(tabla_final_df$negrita)) {
  tabla_kable <- tabla_kable %>% row_spec(i, bold = TRUE, color = "black")
}

# Mostrar la tabla
tabla_kable
```

Mismos modelos para seed number

```{r seed number}
#| warning: false
#| message: false

###models for seed number
formulas.sn <- list(
  m6 = mean.sn ~ poll.sp + plant.sp + (Anidamiento + comp.fun.pol) *  Periodo * Year + (1 | Bosque),
  m7 = mean.sn ~ poll.sp + plant.sp + (Anidamiento + total.visits) *  Periodo * Year + (1 | Bosque)
)

models.g.sn <- map(formulas.sn, ~ glmmTMB(.x, family = "gaussian", data = sitems.fs.g))

formulas.d.sn <- list(
  m6 = mean.fs ~ poll.sp + plant.sp + (Anidamiento + comp.fun.pol) *  Periodo + (1 | Bosque),
  m7 = mean.fs ~ poll.sp + plant.sp + (Anidamiento + total.visits) * Periodo  + (1 | Bosque)
)

models.d.sn <- map(formulas.d.sn, ~ glmmTMB(.x, family = "gaussian", data = sitems.fs.d))

models.d.sub.sn <- map(formulas.d.sn, ~ glmmTMB(.x, family = "gaussian", data = sitems.fs.d.sub))

aic_results <- map(models.g, AIC)
print(aic_results)
aic_results <- map(models.d, AIC)
print(aic_results)
aic_results <- map(models.d.sub, AIC)
print(aic_results)

###tabla
resultados_dsn <- map_dfr(models.d.sn, ~ {
  coef_summary <- summary(.x)$coefficients$cond
  tibble::as_tibble(coef_summary, rownames = "term") %>%
    mutate(modelo = deparse(substitute(.x)), Region = "Doñana")
}, .id = "modelo_d")

resultados_d.sub.sn <- map_dfr(models.d.sub.sn, ~ {
  coef_summary <- summary(.x)$coefficients$cond
  tibble::as_tibble(coef_summary, rownames = "term") %>%
    mutate(modelo = deparse(substitute(.x)), Region = "Doñana")
}, .id = "modelo.d.sub")

# Extraer estimates, std.error y z value para modelos de Gorbea (modelos 2 y 3)
resultados_gsn <- map_dfr(models.g.sn, ~ {
  coef_summary <- summary(.x)$coefficients$cond
  tibble::as_tibble(coef_summary, rownames = "term") %>%
    mutate(modelo = deparse(substitute(.x)), Region = "Gorbea")
}, .id = "modelo_g")

resultados_dsn <- resultados_dsn %>%
  select( Region,model= modelo_d, term, Estimate = Estimate, `Std. Error` = `Std. Error`, `Z value` = `z value`, `p value`= `Pr(>|z|)`)

resultados_d.sub.sn<- resultados_d.sub.sn %>%
  select( Region,model= modelo.d.sub, term, Estimate = Estimate, `Std. Error` = `Std. Error`, `Z value` = `z value`, `p value`= `Pr(>|z|)`)

resultados_gsn <- resultados_gsn %>%
  select(Region, model= modelo_g, term, Estimate = Estimate, `Std. Error` = `Std. Error`, `Z value` = `z value`,  `p value`= `Pr(>|z|)`)


library(kableExtra)
# Combinar los resultados en una sola tabla
tabla_finalsn <- bind_rows(resultados_d.sub.sn, resultados_dsn, resultados_gsn)

tabla_final_df <- as.data.frame(tabla_finalsn)
tabla_final_df <- tabla_final_df %>%
  mutate(negrita =`p value` < 0.05) 
# Crear una tabla con desplazamiento horizontal
tabla_kable <- tabla_final_df %>%
  select(-negrita) %>% 
  kable("html") %>%
  kable_styling("striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#0073e6") %>% # Estilo del encabezado
  column_spec(1:5, border_left = TRUE) # Estilo de columnas

# Aplicar estilo de negrita para las filas con p < 0.05
for (i in which(tabla_final_df$negrita)) {
  tabla_kable <- tabla_kable %>% row_spec(i, bold = TRUE, color = "black")
}

# Mostrar la tabla
tabla_kable
```

**Gorbea**

```{r anidamiento.plot}
#| warning: false
#| message: false


check_and_plot.g <- function(formula) {
  model <- glmmTMB(formula, data = sitems.fs.g, family = "beta_family")
  performance:: check_model(model)               
  effects <- allEffects(model)     
  plot.effects <- plot(effects)                   
  summary(model)  
  return(plot.effects)
}

check_and_plot.d <- function(formula) {
model <- glmmTMB(formula, data = sitems.fs.d, family = "beta_family")
performance:: check_model(model)               
  effects <- allEffects(model)     
  plot.effects <- plot(effects)                   
  summary(model)  
  return(plot.effects)
}

plots.g <- map(formulas, check_and_plot.g)
plots.g <- map(formulas.d, check_and_plot.d)


```

**Doñana,** con punto que cambia modelo quitado

```{r doñana.fs}
#| warning: false
#| message: false

check_and_plot.d.sub <- function(formula) {
model <- glmmTMB(formula, data = sitems.fs.d.sub, family = "beta_family")
performance:: check_model(model)               
  effects <- allEffects(model)     
  plot.effects <- plot(effects)                   
  summary(model)  
  return(plot.effects)
}
plots.dsub<- map(formulas.d, check_and_plot.d.sub)
```

Graficos seleccionando variables:

```{r var}
#| warning: false
#| message: false

sitems.fs.d <- sitems.fs.d %>%
  mutate(efecto_parcial = predict(models.d$m6, type = "response", re.form = NA),
         efecto_m7 =predict(models.d$m7, type = "response", re.form = NA ),
         efecto_sn =predict(models.d.sn$m6, type = "response", re.form = NA),
         efecto_sn.m7=predict(models.d.sn$m7, type = "response", re.form = NA))

sitems.fs.d.sub <- sitems.fs.d.sub %>%
  mutate(efecto_parcial = predict(models.d.sub$m6, type = "response", re.form = NA),
         efecto_m7 =predict(models.d.sub$m7, type = "response", re.form = NA ),
          efecto_sn =predict(models.d.sub.sn$m6, type = "response", re.form = NA),
         efecto_sn.m7=predict(models.d.sub.sn$m7, type = "response", re.form = NA))

sitems.fs.g<- sitems.fs.g%>%
  mutate(efecto_parcial = predict(models.g$m6, type = "response", re.form = NA),
         efecto_m7 =predict(models.g$m7, type = "response", re.form = NA ), 
          efecto_sn =predict(models.g.sn$m6, type = "response", re.form = NA),
         efecto_sn.m7=predict(models.g.sn$m7, type = "response", re.form = NA))

create_plot <- function(data, x_variable) {
  x_labels <- setNames(c("Pollinator richness", "Plant richness",  "Pollinator func. complementarity"), 
                       c("poll.sp", "plant.sp", "comp.fun.pol"))
  ggplot(data, aes_string(x = x_variable, y = "efecto_parcial")) +
     geom_point(alpha = 0.6, color="#069" ) +        
    geom_smooth(method = "lm", color = "#DB5B06", fill = "#DF8F4499", se = TRUE)  + 
    labs(
       x = x_labels[[x_variable]],
      y = "Fruit set"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12)
    )
}

# Variables para las que se generarán los gráficos
variables <- c("poll.sp", "plant.sp", "comp.fun.pol")

# Crear los gráficos usando map
plots <- map(variables, ~ create_plot(sitems.fs.d, .x))

for (p in plots) {
  print(p)
}

plots.sub <- map(variables, ~ create_plot(sitems.fs.d.sub, .x))

for (p in plots.sub) {
  print(p)
}

plots.g <- map(variables, ~ create_plot(sitems.fs.g, .x))

for (p in plots.g) {
  print(p)
}


##seed number
create_plot.sn<- function(data, x_variable) {
  x_labels <- setNames(c("Pollinator richness", "Plant richness",  "Pollinator func. complementarity"), 
                       c("poll.sp", "plant.sp", "comp.fun.pol"))
  ggplot(data, aes_string(x = x_variable, y = "efecto_sn")) +
      geom_point(alpha = 0.6, color="#069" ) +        
    geom_smooth(method = "lm", color = "#DB5B06", fill = "#DF8F4499", se = TRUE) + 
    labs(
       x = x_labels[[x_variable]],
      y = "Seed number"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12)
    )
}

# Variables para las que se generarán los gráficos
variables <- c("poll.sp", "plant.sp", "comp.fun.pol")

# Crear los gráficos usando map
plots <- map(variables, ~ create_plot.sn(sitems.fs.d, .x))

for (p in plots) {
  print(p)
}

plots.sub <- map(variables, ~ create_plot.sn(sitems.fs.d.sub, .x))

for (p in plots.sub) {
  print(p)
}

plots.g <- map(variables, ~ create_plot.sn(sitems.fs.g, .x))

for (p in plots.g) {
  print(p)
}

sitems.fs.d$Periodo <- as.factor(sitems.fs.d$Periodo)

ggplot(sitems.fs.d, aes(x = Periodo, y = efecto_parcial)) +
  geom_boxplot(fill = "#8491B4FF", color = "#3C5488B2", outlier.colour = "#F39B7FB2", outlier.size = 2) + 
  labs(
    title = "Fruit set througout sampling period",
    x = "Sampling period",
    y = "Fruit set"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title = element_text(size = 12)
  )

```

```{r m7}
create_plot.m7 <- function(data, x_variable) {
  x_labels <- setNames(c("Pollinator richness", "Plant richness",  "Total visits"), 
                       c("poll.sp", "plant.sp", "total.visits"))
  ggplot(data, aes_string(x = x_variable, y = "efecto_m7")) +
       geom_point(alpha = 0.6, color="#069" ) +        
    geom_smooth(method = "lm", color = "#DB5B06", fill = "#DF8F4499", se = TRUE) + 
    labs(
       x = x_labels[[x_variable]],
      y = "Fruit set"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12)
    )
}

# Variables para las que se generarán los gráficos
variables <- c("poll.sp", "plant.sp", "total.visits")

# Crear los gráficos usando map
plots <- map(variables, ~ create_plot.m7(sitems.fs.d, .x))

for (p in plots) {
  print(p)
}

plots.sub <- map(variables, ~ create_plot.m7(sitems.fs.d.sub, .x))

for (p in plots.sub) {
  print(p)
}

plots.g <- map(variables, ~ create_plot(sitems.fs.g, .x))

for (p in plots.g) {
  print(p)
}


##seed number
create_plot.sn.m7<- function(data, x_variable) {
  x_labels <- setNames(c("Pollinator richness", "Plant richness",  "Total visits"), 
                       c("poll.sp", "plant.sp", "total.visits"))
  ggplot(data, aes_string(x = x_variable, y = "efecto_sn")) +
       geom_point(alpha = 0.6, color="#069" ) +        
    geom_smooth(method = "lm", color = "#DB5B06", fill = "#DF8F4499", se = TRUE)  + 
    labs(
       x = x_labels[[x_variable]],
      y = "Seed number"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12)
    )
}

# Variables para las que se generarán los gráficos
variables <- c("poll.sp", "plant.sp", "total.visits")

# Crear los gráficos usando map
plots <- map(variables, ~ create_plot.sn.m7(sitems.fs.d, .x))

for (p in plots) {
  print(p)
}

plots.sub <- map(variables, ~ create_plot.sn.m7(sitems.fs.d.sub, .x))

for (p in plots.sub) {
  print(p)
}

plots.g <- map(variables, ~ create_plot.sn.m7(sitems.fs.g, .x))

for (p in plots.g) {
  print(p)
}
```

plots

```{r cv}
fs <- read.csv(here("data", "total_fs.csv"))
fs <- fs %>%
  group_by(Site, Year, Bosque, Periodo) %>%
  summarize(
    Media = mean(fruit_set, na.rm = TRUE),
    Desviacion = sd(fruit_set, na.rm = TRUE),
    CV = (Desviacion / Media)  
  )

fs$Year <- as.factor (fs$Year)
fs_expanded <- fs %>%
  left_join(sitems_rescaled %>% 
              select(Site_id, Year, Bosque, Periodo, total.visits, poll.sp, plant.sp), 
            by = c("Site" = "Site_id", "Year", "Bosque", "Periodo"))

fs_expanded$Periodo <- as.factor(fs$Periodo)

library(lmerTest)
modelo <- lmer(CV ~ total.visits + poll.sp + plant.sp + Periodo + (1|Site) + (1|Bosque), data = fs_expanded, na.action = na.exclude)

summary(modelo)
###aumento de diversdiad de polinizadores disminuye la variacion. es decir aumenta la estabilidad dek exito reproductivo.

##aumento de diversidad de plantas aumenta la variacion asiqeue disminuye la estabilidad. 

## la cantidad total de visitas registradas no tiene ningun efcto en la estabilidad. 

plot(modelo)

anova(modelo, ddf = "Kenward-Roger")

modelo_nulo <- lmer(CV ~ 1 + (1|Site) + (1|Bosque), data = fs_expanded, na.action = na.exclude)
anova(modelo_nulo, modelo)

fs$Year <- as.factor(fs$Year)
library(ggsci)
p1 <- ggplot(fs, aes(x = Periodo, y = CV, color = Year)) +
  geom_point() +
  geom_smooth()+
  facet_wrap(~ Site) +
  labs(title = "",
       x = "Period",
       y = "Fruit set CV") +
  theme_minimal() +
  scale_color_npg() +
  scale_x_continuous(breaks = 1:9) 
  
library(ggeffects)

predicciones <- ggpredict(modelo, terms = "poll.sp")

variables_x <- "poll.sp"
variables_y <- "CV"  

library(broom.mixed)
modelo_summary <- tidy(modelo, effects = "fixed")

annotations <- map(variables_x, ~ {
  coef_info <- modelo_summary %>% filter(term == .x)
  list(
    estimate = round(coef_info$estimate, 4),
    p_value = round(coef_info$p.value, 4)
  )
})

plots <- map(variables_x, ~ {
   annotation_data <- annotations[[1]] 
  ggplot(fs_expanded, aes(x= .data[[.x]], y = fs_expanded[[variables_y]])) +
    geom_point(alpha = 0.6, color="#069") +  
    geom_ribbon(data = predicciones, aes(x = x, ymin = conf.low, ymax = conf.high), 
                fill = "#DF8F4499", alpha = 0.2, inherit.aes = FALSE) + 
    geom_line(data = predicciones, aes(x = x, y = predicted), color = "#DB5B06", linewidth=1.2) + 
    labs(x = "Pollinator richness" , y = "Fruit Set CV") +
    annotate(
      "text",
      x = 1.75,
      y = 1.5,
      label = paste0("Estimate: ", annotation_data$estimate, "\n", "p-value: ", annotation_data$p_value),
      hjust = 0, size = 4, color = "black"
    ) +
    theme_minimal()
})

p2 <- plots[[1]]


save(p1,plots,fs_expanded, variables_y, file = "Rdata/cv_fs.RData" )

```

```{r cv_compl}
comp <- sitems_rescaled %>%
  group_by(Site_id, Year, Bosque) %>%
  summarize(
    Media = mean(comp.fun.pol, na.rm = TRUE),
    Desviacion = sd(comp.fun.pol, na.rm = TRUE),
    CV = (Desviacion / Media) )

comp$Year <- as.factor(comp$Year)

p1 <- ggplot(comp, aes(x = Bosque, y = CV, color = Year)) +
  geom_point() +
  geom_line() +
  facet_wrap(~ Site_id, scales = "free_x", labeller = label_wrap_gen(multi_line = FALSE)) +
  labs(title = "Pollinator complementarity CV",
       x = "Sampling site",
       y = "Coefficient of Variation (%)") +
  theme_minimal() +
  scale_color_npg() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1

mean_fs_data <- sitems_rescaled %>%
  group_by(Site_id, Year, Bosque) %>%
  summarize(mean_fs = mean(mean.fs, na.rm = TRUE),
            .groups = 'drop')

comp_expanded <- comp %>%
  left_join(mean_fs_data, by = c("Site_id", "Year", "Bosque"))

comp_final <- comp_expanded %>%
  filter(Year != 2020)



modelo <- lmer(mean_fs ~ CV + (1|Site_id), data = comp_final)
resumen <- summary(modelo)
print(resumen)
anova(modelo, ddf = "Kenward-Roger")

modelo_nulo <- lmer(mean_fs ~ 1 + (1|Site_id), data = comp_final)
anova(modelo_nulo, modelo)
###NO PODEMOS RECHAZAR HIPOTESIS NULA, DE QUE NO HAY RELACION ENTRE CV DEL NESTEDNESS Y MEAN FRUITSET. 
##pendiente de la linea: 0.0031, p value 0.59

# Obtener las predicciones del modelo
predicciones <- ggpredict(modelo, terms = "CV")


# Crear el gráfico
p.cv_comp <- ggplot(comp_final, aes(x = CV, y = mean_fs)) +
  geom_point(alpha = 0.6, color="#069") +  
 geom_ribbon(data = predicciones, aes(x = x, ymin = conf.low, ymax = conf.high), 
              fill = "#DF8F4499", alpha = 0.2, inherit.aes = FALSE)+ 
  geom_line(data = predicciones, aes(x = x, y = predicted), color = "#DB5B06", linewidth=1.2) + 
  labs(x = "CV of Poll.complementarity", y = "Mean Fruit Set"
       ) +
  annotate("text", 
           x = min(comp_final$CV, na.rm = TRUE) + 2,  
           y = max(comp_final$mean_fs, na.rm = TRUE) - 0.1,             label = "Estimate: 0.0031\np-value: 0.59", 
           hjust = 0, size = 4, color = "black") + 
  theme_minimal()

print(p.cv_comp)
```

```{r cv_nest}
hinojos <- sitems_rescaled %>%
  filter(Bosque == "Pinar Hinojos" & Year==2021) %>%
  summarize(
    Media.nest = mean(Anidamiento, na.rm = TRUE),
    Desviacion.nest = sd(Anidamiento, na.rm = TRUE),
    CV.mest = (Desviacion.nest / Media.nest),
    Media.comp = mean(comp.fun.pol, na.rm = TRUE),
    Desviacion.comp = sd(comp.fun.pol, na.rm = TRUE),
    CV.comp = (Desviacion.comp / Media.comp))

nest <- sitems_rescaled %>%
  group_by(Site_id, Year, Bosque) %>%
  summarize(
    Media = mean(Anidamiento, na.rm = TRUE),
    Desviacion = sd(Anidamiento, na.rm = TRUE),
    CV = (Desviacion / Media) )

nest$Year <- as.factor(nest$Year)

p1 <- ggplot(nest, aes(x = Bosque, y = CV, color = Year)) +
  geom_point() +
  geom_line() +
  facet_wrap(~ Site_id, scales = "free_x", labeller = label_wrap_gen(multi_line = FALSE)) +
  labs(title = "Nestednesss CV",
       x = "Sampling site",
       y = "Coefficient of Variation (%)") +
  theme_minimal() +
  scale_color_npg() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1


nest_expanded <- nest %>%
  left_join(mean_fs_data, by = c("Site_id", "Year", "Bosque"))

nest_final <- nest_expanded %>%
  filter(Year != 2020)



modelo <- lmer(mean_fs ~ CV + (1|Site_id), data = nest_final)
resumen <- summary(modelo)
print(resumen)
anova(modelo, ddf = "Kenward-Roger")

modelo_nulo <- lmer(mean_fs ~ 1 + (1|Site_id), data = comp_final)
anova(modelo_nulo, modelo)
###NO PODEMOS RECHAZAR HIPOTESIS NULA, DE QUE NO HAY RELACION ENTRE CV DEL NESTEDNESS Y MEAN FRUITSET. 
##pendiente de la linea: 0.0013, p value 0.39

# Obtener las predicciones del modelo
predicciones <- ggpredict(modelo, terms = "CV")

# Crear el gráfico
p.cv_nest <- ggplot(nest_final, aes(x = CV, y = mean_fs)) +
  geom_point(alpha = 0.6, color="#069") +  
  geom_ribbon(data = predicciones, aes(x = x, ymin = conf.low, ymax = conf.high), 
              fill = "#DF8F4499", alpha = 0.2, inherit.aes = FALSE)+ 
  geom_line(data = predicciones, aes(x = x, y = predicted), color = "#DB5B06", linewidth=1.2) +   # Línea del modelo con intervalo de confianza
  labs(x = "Nestedness CV", y = "Mean Fruit Set",
       ) +
  annotate("text", 
           x = min(nest_final$CV, na.rm = TRUE) + 5,  
           y = max(nest_final$mean_fs, na.rm = TRUE) - 0.1,             label = "Estimate: 0.0013\np-value: 0.39", 
           hjust = 0, size = 4, color = "black") + 
  theme_minimal()

print(p.cv_nest)

library(cowplot)
combined_plot <- plot_grid(
  p.cv_nest + ggtitle("A"),  
  p.cv_comp + ggtitle("B"), 
  label_size = 12,  
  ncol = 2  
)


ggsave("Figs/cv_nest_comp.png", combined_plot, dpi=300, width=10, height = 6, bg= "white")
```

### Indices de estructura de la red

```{r plots}

library(ggplot2)
library(ggsci)
library(ggpubr)
library(purrr)

sitems_rescaled$Periodo <- as.numeric(sitems_rescaled$Periodo)
# Filtrar los datasets
sitems.g <- sitems_rescaled %>% filter(Site_id == "Gorbea")
sitems.d <- sitems_rescaled %>% filter(Site_id == "Doñana")

str(sitems.g)

model_glmmTMB.g <- glmmTMB(
  Anidamiento ~ poll.sp + plant.sp + Periodo + (1 | Bosque) + (1 | Year),
  family = "gaussian",
  data = sitems.g
)

model_lme.g <- lme(
  Anidamiento ~ poll.sp + plant.sp,
  random = list( ~ 1 | Bosque, ~ 1 | Year),
  correlation = corAR1(form = ~ Periodo),
  data = sitems.g
)

model_glmmTMB.d <- glmmTMB(
  Anidamiento ~ poll.sp + plant.sp + Periodo + (1 | Bosque) + (1 | Year),
  family = "gaussian",
  data = sitems.d
)

model_lme.d <- lme(
  Anidamiento ~ poll.sp + plant.sp,
  random = list( ~ 1 | Bosque, ~ 1 | Year),
  correlation = corAR1(form = ~ Periodo),
  data = sitems.d
)



model_comparison1 <- data.frame(
  Model = c("glmmTMB", "lme"),
  AIC = c(AIC(model_glmmTMB.g), AIC(model_lme.g), AIC(model_glmmTMB.d), AIC(model_lme.d)),
  BIC = c(BIC(model_glmmTMB.g), BIC(model_lme.g), BIC(model_glmmTMB.d), BIC(model_lme.d))
)

# Mostrar comparación de AIC y BIC
print(model_comparison1)

par(mfrow = c(2, 2))
plot(resid(model_glmmTMB) ~ fitted(model_glmmTMB),
     main = "Residuos glmmTMB",
     xlab = "Valores ajustados",
     ylab = "Residuos")
abline(h = 0, col = "red")
# Histograma de residuos
hist(resid(model_glmmTMB), main = "Histograma de residuos glmmTMB", xlab = "Residuos")

# Análisis de residuos para el modelo lme
plot(resid(model_lme) ~ fitted(model_lme),
     main = "Residuos lme",
     xlab = "Valores ajustados",
     ylab = "Residuos")
abline(h = 0, col = "red")

# Histograma de residuos
hist(resid(model_lme), main = "Histograma de residuos lme", xlab = "Residuos")
models.full <- map(formulas, ~ glmmTMB(.x, family = "beta_family", data = sitems.fs))




# Crear lista de datasets con nombres completos
datasets <- list(Gorbea = sitems.g, Doñana = sitems.d)
models <- list(
  anidamiento = Anidamiento ~ Periodo + poll.sp + plant.sp + Year + (1|Bosque),
  comp_pol = comp.fun.pol ~ Periodo + poll.sp + plant.sp + Year + (1|Bosque),
  comp_pl = comp.fun.pl ~ Periodo + poll.sp + plant.sp + Year + (1|Bosque) 
)

results <- function(data, formula) {
  model <- glmmTMB(formula, data = data, family = "gaussian")
  
  # Resumen del modelo
  model_summary <- summary(model)
  
  
  return(model_summary)
}

# Usar map para calcular resultados
results_all <- map(models, ~ map(datasets, results, formula = .x))

# Visualización de los resultados
results_all


# Función para ajustar modelos y generar predicciones
predict_and_summarise <- function(data, formula) {
  model <- glmmTMB(formula, data = data, family = "gaussian")
  data$predicted <- predict(model, type = "response", re.form = NA)
  
  mean_predictions <- data %>%
    group_by(Year, Periodo) %>%
    summarise(mean_predicted = mean(predicted, na.rm = TRUE), .groups = 'drop')
  
  return(list(data = data, mean_predictions = mean_predictions))
}

# Función para crear gráficos
create_plot <- function(data, mean_predictions, y_variable, plot_title) {
  ggplot(data, aes_string(x = "Periodo", y = y_variable)) +
    geom_point(aes(color = as.factor(Year)), alpha = 0.6) +
    geom_line(aes(y = predicted), color = "#3C5488FF", alpha = 0.75, size = 0.7) +
    geom_point(data = mean_predictions, aes_string(y = "mean_predicted"),
               color = "#3C5488FF", size = 2.5, shape = 21, fill = "#3C5488FF", alpha = 0.75) +
    geom_line(data = mean_predictions, aes_string(y = "mean_predicted", group = "Year"),
              color = "#3C5488FF", size = 0.7, alpha = 0.75) +
    facet_wrap(~ Year) +
    scale_color_npg() +
    theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    labs(x = "Periodo", y = ifelse(y_variable == "Anidamiento", "Anidamiento", 
                                     ifelse(y_variable == "comp.fun.pl", "Functional Complementarity of Plants", " Poll. Functional Complementarity")), 
         color = "Year") +
    ggtitle(plot_title)
}

# Aplicar modelos y generar gráficos para cada combinación
results <- map(models, ~ map(datasets, predict_and_summarise, formula = .x))


plots <- map2(results, names(results), function(res, model_name) {
  map2(res, names(res), function(data_res, site_name) {
    y_variable <- ifelse(model_name == "anidamiento", "Anidamiento",
                  ifelse(model_name == "comp_pl", "comp.fun.pl", "comp.fun.pol"))
    create_plot(data_res$data, data_res$mean_predictions, y_variable, paste(site_name, model_name))
  })
})

# Mostrar gráficos
plots <- walk(plots, ~ walk(.x, print))
save(plots,file = "Rdata/indices.RData")

```

```{r bosque}
predict_bosque <- function(data, formula) {
  model <- glmmTMB(formula, data = data, family = "gaussian")
  data$predicted <- predict(model, type = "response", re.form = NA)
  
  mean_predictions <- data %>%
    group_by(Year, Periodo, Bosque) %>%
    summarise(mean_predicted = mean(predicted, na.rm = TRUE), .groups = 'drop')
  
  return(list(data = data, mean_predictions = mean_predictions))
}
sortu_plot <- function(data, mean_predictions, y_variable, plot_title) {
ggplot(data, aes_string(x = "Periodo", y = y_variable)) +
    geom_point(aes(color = as.factor(Year)), alpha = 0.6) +
    geom_point(data = mean_predictions, aes_string(y = "mean_predicted", color = "as.factor(Year)"),
               size = 2.5, shape = 21, fill = "#3C5488FF", alpha = 0.75) +
    geom_line(data = mean_predictions, aes_string(y = "mean_predicted", group = "Year", color = "as.factor(Year)"),
              size = 0.7, alpha = 0.75) +
    facet_wrap(~ Bosque) +  # Facetar por Bosque
    scale_color_npg() +
    theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    labs(x = "Periodo", y = ifelse(y_variable == "Anidamiento", "Anidamiento", 
                                   ifelse(y_variable == "comp.fun.pl", "Functional Complementarity of Plants", "Functional Complementarity")), 
         color = "Year") +
    ggtitle(plot_title)
}

# Aplicar modelos y generar gráficos para cada combinación
results <- map(models, ~ map(datasets, predict_bosque, formula = .x))

# Generar gráficos usando la información de `results`
plots <- map2(results, names(results), function(res, model_name) {
  map2(res, names(res), function(data_res, site_name) {
    y_variable <- ifelse(model_name == "anidamiento", "Anidamiento",
                  ifelse(model_name == "comp_pl", "comp.fun.pl", "comp.fun.pol"))
    sortu_plot(data_res$data, data_res$mean_predictions, y_variable, paste(site_name))
  })
})

# Mostrar gráficos
plots<-walk(plots, ~ walk(.x, print))
save(plots,file = "Rdata/indices_bosque.RData")
```
